Index: csv_formatter/main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import argparse\nimport glob\nimport io\nimport logging\nimport os\nfrom datetime import datetime\n\nimport pandas as pd\n\n# Create a logger\nlogger = logging.getLogger(\"csv_formatter_logger\")\n\n\ndef setup_logger():\n    logger.setLevel(logging.DEBUG)  # Set the minimum level to log\n\n    # Create a file handler\n    timestamp = datetime.now().strftime(\"%Y-%m-%d_%H-%M-%S\")\n    file_handler = logging.FileHandler(f\"csv_reformater_{timestamp}.log\")\n    file_handler.setLevel(logging.INFO)  # Log everything to the file\n\n    # Create a console (stdout) handler\n    console_handler = logging.StreamHandler()\n    console_handler.setLevel(logging.INFO)  # Only log INFO and above to stdout\n\n    # Define a formatter\n    formatter = logging.Formatter(\"%(asctime)s - %(levelname)s - %(message)s\")\n\n    # Apply the formatter to both handlers\n    file_handler.setFormatter(formatter)\n    console_handler.setFormatter(formatter)\n\n    # Add handlers to the logger\n    logger.addHandler(file_handler)\n    logger.addHandler(console_handler)\n\n\nclass ResultDataSet:\n    data: pd.DataFrame = None\n    header: list = None\n\n    def __init__(self, path: str):\n        self.read_csv(path)\n\n    def clean_up_raw_csv(self, raw_csv: [str]):\n        column_headers = raw_csv[0].strip().split(\",\")\n        num_cols = 0\n        for header in column_headers:\n            if len(header) > 0:\n                num_cols += 1\n        column_headers += [''] * num_cols\n        new_headers = []\n        current_header = \"\"\n        for header in column_headers:\n            if len(header) > 0: # header needs to be saved\n                logger.debug(f\"reading header: {header}\")\n                current_header = header\n            new_headers.append(current_header)\n        final_headers = \",\".join(new_headers)\n        final_headers = final_headers.strip(\",\\n\") + \"\\n\"\n        logger.debug(final_headers)\n        raw_csv[0] = final_headers\n        return raw_csv\n\n\n    def parse_raw_csv(self, raw_data: io.StringIO):\n        self.data = pd.read_csv(raw_data, header=[0, 1])\n        self.data.columns = self.data.columns.map(lambda x: (x[0].strip('\"'), x[1].strip('\"')))\n        self.data = self.data.apply(pd.to_numeric)\n\n    def read_csv(self, path):\n        with open(path, \"r\") as csv_file:\n            raw_data = csv_file.readlines() # read the file header first\n            self.header = raw_data[:17]\n            clean_csv = self.clean_up_raw_csv(raw_data[17:])\n            clean_csv_buffer = io.StringIO(\"\".join(clean_csv))\n            self.parse_raw_csv(clean_csv_buffer)\n\n    def reorganize_data(self):\n        self.data = self.data.stack(level=0, future_stack=True)\n        self.data = self.data.iloc[self.data.index.get_level_values(1).argsort(kind='stable')]\n        self.data.index.names = [\"index\", \"course\"]\n        self.data.drop(columns=[\"color\", \"pen down?\"], inplace=True)\n        self.data.rename(columns={\"x\": \"ticks\", \"y\": \"happy\"}, inplace=True)\n        logger.debug(self.data.index)\n\n    def export_csv(self, path):\n        output = \"\".join(self.header)\n        output += self.data.reset_index(level=0, drop=True).to_csv()\n        with open(path, \"w\") as csv_file:\n            csv_file.write(output)\n\n\ndef process_files(input_pattern, output_folder):\n    files = glob.glob(input_pattern)\n    if not files:\n        logger.error(\"No matching files found.\")\n        return\n\n    for file in files:\n        logger.info(f\"Processing file: {file}\")\n        data = ResultDataSet(file)\n        data.reorganize_data()\n        output_file = os.path.join(output_folder, os.path.basename(file))\n        data.export_csv(output_file)\n        logger.info(f\"Exported to: {output_file}\")\n\ndef main():\n    setup_logger()\n\n    parser = argparse.ArgumentParser(description=\"NetLogo CSV Reformatter\")\n    parser.add_argument(\"input\", help=\"Input CSV file or wildcard pattern (e.g., '../measurement_*.csv')\")\n    parser.add_argument(\"output_folder\", help=\"Output folder for reformatted CSV files\")\n\n    args = parser.parse_args()\n\n    if not os.path.exists(args.output_folder):\n        os.makedirs(args.output_folder)\n\n    process_files(args.input, args.output_folder)\n\n\nif __name__ == \"__main__\":\n    main()\n
===================================================================
diff --git a/csv_formatter/main.py b/csv_formatter/main.py
--- a/csv_formatter/main.py	(revision 976ccbbe3f22de5530d52fc496586d0a3d582114)
+++ b/csv_formatter/main.py	(date 1742548983493)
@@ -43,12 +43,8 @@
         self.read_csv(path)
 
     def clean_up_raw_csv(self, raw_csv: [str]):
-        column_headers = raw_csv[0].strip().split(",")
-        num_cols = 0
-        for header in column_headers:
-            if len(header) > 0:
-                num_cols += 1
-        column_headers += [''] * num_cols
+        column_headers = raw_csv[0].strip()
+        column_headers += [''] * 4 # NetLogo does not add these
         new_headers = []
         current_header = ""
         for header in column_headers:
